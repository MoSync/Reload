/**
 *  Module dependencies.
 */
var fs   = require('fs')
  , path = require('path');
 

/**
 * Utility functions to synchronously test whether the giving path 
 * is a file or a directory.
 */
var is = (function(ret) {
  ['File', 'Directory'].forEach(function(method) {
    ret[method] = function(fpath) {
      if (fs.existsSync(fpath)) {
        memo.push(fpath, method);
        return fs.statSync(fpath)['is'+method](); 
      }
      return false;
    }
  });
  return ret;
}({}));


/**
 *  Get sub-directories in a directory.
 */
var sub = function(dir, cb) {
  if (is.Directory(dir)) {
    fs.readdir(dir, function(err, files) {
      files && files
        .filter(function(n) { return is.Directory(path.join(dir, n)) })
        .forEach(function(n) { cb.call(null, path.join(dir, n)) });
    });
  }
};


/**
 * A container for memorizing names of files or directories.
 */
var memo = (function(memo) {
  return {
    push: function(name, type) {
      memo[name] = type;
    }, 
    has: function(name) {
      return memo.hasOwnProperty(name) ? true : false;
    },
    update: function(name) {
      if (!is.File(name) || !is.Directory(name)) {
        delete memo[name];
      }
      return true;
    }
  };
}({}));

  
/**
 *  A Container for storing unique and valid filenames.
 */
var fileNameCache = (function(cache) {
  return {
    push: function(name) {
      cache[name] = 1;
      return this;
    },
    each: function() {
      var temp = Object.keys(cache).filter(function(name){ 
        return is.File(name) || memo.has(name) && memo.update(name);
      });
      temp.forEach.apply(temp, arguments);
      return this;
    },
    clear: function(){
      cache = {};
      return this;
    }
  };
}({}));     


/**
 * Abstracting the way of avoiding duplicate function call.
 */
var worker = (function() {
  var free = true;
  return {
    busydoing: function(cb) {
      if (free) {
        free = false;
        cb.call();
      }
    },
    free: function() {
      free = true;
    }
  }
}());


/**
 * Delay function call and ignore invalid filenames.
 */
var normalizeCall = function(fname, cb) {
  // Store each name of the modifying or temporary files generated by an editor.
  fileNameCache.push(fname);

  worker.busydoing(function() {
    // A heuristic delay of the write-to-file process.  
    setTimeout(function() {
      
      // When the write-to-file process is done, send all filtered filenames
      // to the callback function and call it.
      fileNameCache
        .each(function(f) { 
          // Watch new created directory.
          memo.has(f) || is.Directory(f) && watch(f, cb);
          cb.call(null, f); 
        }).clear();

      worker.free();

    }, 100);
  });
};


/**
 * Watch a file or a directory recursively.
 *  
 * @param {String} fpath
 * @param {Function} cb
 * 
 *   watch('fpath', function(file) {
 *     console.log(file, ' changed');
 *   });
 */
function watch(fpath, cb) {

  // Due to the unstalbe fs.watch(), if the `fpath` is a file then 
  // switch to watch its parent directory instead of watch it directly. 
  // Once the logged filename matches it then triggers the callback function.
  if (is.File(fpath)) {
    var parent = path.resolve(fpath, '..');
    fs.watch(parent, function(err, fname) {
      if (path.basename(fpath) === fname) {
        normalizeCall(fpath, cb);
      }
    });                        
  } else if (is.Directory(fpath)) {
    fs.watch(fpath, function(err, fname) {
      normalizeCall(path.join(fpath, fname), cb);
    });
    // Recursively watch its sub-directories. 
    sub(fpath, function(dir) {
      watch(dir, cb);
    });    
  }

}; 


// Expose.
module.exports = watch;

